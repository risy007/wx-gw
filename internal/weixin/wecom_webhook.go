package weixin

import (
	"crypto/tls"
	"errors"
	"github.com/xen0n/go-workwx/v2"
	"go.uber.org/zap"
	"golang.org/x/net/http2"
	"io"
	"net"
	"net/http"
	"os"
	"time"
	"wx-gw/config"
)

type (
	Service struct {
		log           *zap.Logger
		cfg           *config.Config
		WebHookClient *workwx.WebhookClient
	}
)

func NewWxService(conf *config.Config, log *zap.Logger) (service *Service, err error) {
	if conf.Weixin == nil {
		return nil, errors.New("weixin config is nil")
	}
	if conf.Weixin.CorpID == "" || conf.Weixin.CorpSecret == "" {
		return nil, errors.New("Weixin CorpID or CorpSecret is empty")
	}
	service = &Service{
		log: log,
		cfg: conf,
	}
	return service, nil
}

func (s *Service) Start() {
	wh := s.makeWebhookClient()
	s.WebHookClient = wh
	s.log.Info("创建 WebHook 客户端成功")
}

func (s *Service) makeWebhookClient() *workwx.WebhookClient {
	c := s.cfg.Weixin
	if c.WebhookKey == "" {
		s.log.Fatal("webhook key must be set")
	}

	httpClient := s.makeHTTPClient()
	if c.QYAPIHostOverride != "" {
		// wtf think of a way to change this
		return workwx.NewWebhookClient(c.WebhookKey,
			workwx.WithQYAPIHost(c.QYAPIHostOverride),
			workwx.WithHTTPClient(httpClient),
		)
	}
	return workwx.NewWebhookClient(c.WebhookKey, workwx.WithHTTPClient(httpClient))

}

func (s *Service) makeHTTPClient() *http.Client {
	cfg := s.cfg.Weixin
	if cfg.TLSKeyLogFile == "" {
		return http.DefaultClient
	}

	f, err := os.OpenFile(cfg.TLSKeyLogFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		s.log.Fatal("can't open TLS key log file for writing: %+v\n")
		return nil
	}

	s.log.Info("# SSL/TLS secrets log file, generated by go\n")

	return &http.Client{
		Transport: s.newTransportWithKeyLog(f),
	}
}

func (s *Service) newTransportWithKeyLog(keyLog io.Writer) *http.Transport {
	transport := &http.Transport{
		//nolint: gosec  // this transport is delibrately made to be a side channel
		TLSClientConfig: &tls.Config{KeyLogWriter: keyLog, InsecureSkipVerify: true},

		// Copy of http.DefaultTransport
		Proxy: http.ProxyFromEnvironment,
		DialContext: (&net.Dialer{
			Timeout:   30 * time.Second,
			KeepAlive: 30 * time.Second,
			DualStack: true,
		}).DialContext,
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
	}
	if err := http2.ConfigureTransport(transport); err != nil {
		s.log.Fatal(err.Error())
		return nil
	}
	return transport
}

func (s *Service) SendTextMessage(msg string) {
	err := s.WebHookClient.SendTextMessage(msg, nil)
	if err != nil {
		s.log.Error(err.Error(), zap.String("msg", msg))
	}
}

func (s *Service) SendMarkDownMessage(msg string) {
	go s.WebHookClient.SendMarkdownMessage(msg)
}
